<html>
  <head>
    <style>
      * {
        margin:0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Poppins", sans-serif;
      }

      body {
        height: 100vh;
        width: 100%;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(#2196f3, #e91e63);
      }

      .bubbles {
        position: absolute;
        bottom: -120px;
        display: flex;
        flex-wrap: wrap;
        margin-top: 70px;
        width: 100%;
        justify-content: space-around;
      }

      .bubbles span {
        width: 50px;
        aspect-ratio: 1;
        border-image: radial-gradient(#e91e63 69%, #0000 70%) 84.5% fill/100%;
        clip-path: polygon(-41% 0, 50% 91%, 141% 0);
        animation: move 10s linear infinite;
        position: relative;
        overflow: hidden;
      }

      @keyframes move {
        100% {
          transform: translateY(-100vh);
        }
      }

      .bubbles span.one {
        animation-delay: 2.2s;
        transform: scale(2.15);
      }

      .bubbles span.two {
        animation-delay: 3.5s;
        transform: scale(1.55);
      }

      .bubbles span.three {
        animation-delay: 0.2s;
        transform: scale(0.35);
      }

      .bubbles span.four {
        animation-delay: 6s;
        transform: scale(2.15);
      }

      .bubbles span.five {
        animation-delay: 7s;
        transform: scale(0.5);
      }

      .bubbles span.six {
        animation-delay: 4s;
        transform: scale(2.5);
      }

      .bubbles span.seven {
        animation-delay: 3s;
        transform: scale(1.5);
      }

      .bubbles span:before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        height: 60px;
        width: 40%;
        transform: skew(45deg) translateX(150px);
        /* background: rgba(255, 255, 255, 0.15); */
        animation: mirror 3s linear infinite;
      }

      @keyframes mirror {
        100% {
          transform: translateX(-450px);
        }
      }

      .bubbles span.one:before {
        animation-delay: 1.5s;
      }

      .bubbles span.two:before {
        animation-delay: 3.5s;
      }

      .bubbles span.three:before {
        animation-delay: 2.5s;
      }

      .bubbles span.four:before {
        animation-delay: 7.5s;
      }

      .bubbles span.five:before {
        animation-delay: 4.5s;
      }

      .bubbles span.six:before {
        animation-delay: 0.5s;
      }

      .bubbles span.seven:before {
        animation-delay: 6s;
      }

      .container {
        z-index: 12;
        width: 360px;
        padding: 15px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.1);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.15);
        border-top: 1px solid rgba(255, 255, 255, 0.5);
        border-left: 1px solid rgba(255, 255, 255, 0.5);
      }

      .container input[type="text"] {
        width: 100%;
        height: 100px;
        margin: 0 3px;
        outline: none;
        border: none;
        color: #fff;
        font-size: 20px;
        text-align: right;
        padding-right: 10px;
        pointer-events: none;
        background: transparent;
      }

      .container input[type="button"] {
        height: 65px;
        color: #fff;
        width: calc(100% / 4 - 5px);
        background: transparent;
        border-radius: 12px;
        margin-top: 15px;
        outline: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .container input[type="button"]:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      input {
        background: 0;
        width: 200px;
        outline: 0;
        border: 0;
        border-bottom: 2px solid rgba(255, 255, 255, 0.3);
        margin: 20px 0;
        padding-bottom: 10px;
        font-size: 18px;
        font-weight: bold;
        color: rgba(255, 255, 255, 0.8);
      }

      input[type="button"] {
        border: 0;
        border-radius: 8px;
        padding-bottom: 0;
        height: 60px;
        background: #df2359;
        color: white;
        cursor: pointer;
        transition: all 600ms ease-in-out;
      }

      input[type="button"]:hover {
        background: #c0392b;
      }
    </style>
  </head>
  <div class="bubbles">
    <span class="one"></span>
    <span class="two"></span>
    <span class="three"></span>
    <span class="four"></span>
    <span class="five"></span>
    <span class="six"></span>
    <span class="seven"></span>
    <span class="seven"></span>
  </div>
  <div class="bubbles">
    <span class="one"></span>
    <span class="two"></span>
    <span class="three"></span>
    <span class="four"></span>
    <span class="five"></span>
    <span class="six"></span>
    <span class="seven"></span>
    <span class="seven"></span>
  </div>
  <div class="bubbles">
    <span class="one"></span>
    <span class="two"></span>
    <span class="three"></span>
    <span class="four"></span>
    <span class="five"></span>
    <span class="six"></span>
    <span class="seven"></span>
    <span class="seven"></span>
  </div>
  <div class="bubbles">
    <span class="one"></span>
    <span class="two"></span>
    <span class="three"></span>
    <span class="four"></span>
    <span class="five"></span>
    <span class="six"></span>
    <span class="seven"></span>
    <span class="seven"></span>
  </div>
  <div id="container">
    <input type="text" value="" id="male" placeholder="Enter Male Name" /><br />
    <input type="text" id="female" placeholder="Enter Female Name" /><br />
    <input type="button" value="Match" id="btn" /><br />
  </div>
  <script>
    window.module = {};
  </script>
  <script type="text/javascript" src="sweet.js"></script>
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/canvas-confetti/1.5.1/confetti.min.js" integrity="sha512-jnHyUkgsWMgEENOHYzcnwB8BIs3CR9TbY0gKvnK/b0huYMV1u2HjUnbNTKxWwwKfwSBrfISUXafurOK1lqFrCA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> -->
  <script>
    (function main(global, module, isWorker, workerSize) {
      var canUseWorker = !!(
        global.Worker &&
        global.Blob &&
        global.Promise &&
        global.OffscreenCanvas &&
        global.OffscreenCanvasRenderingContext2D &&
        global.HTMLCanvasElement &&
        global.HTMLCanvasElement.prototype.transferControlToOffscreen &&
        global.URL &&
        global.URL.createObjectURL
      );

      function noop() {}

      // create a promise if it exists, otherwise, just
      // call the function directly
      function promise(func) {
        var ModulePromise = module.exports.Promise;
        var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;

        if (typeof Prom === "function") {
          return new Prom(func);
        }

        func(noop, noop);

        return null;
      }

      var raf = (function () {
        var TIME = Math.floor(1000 / 60);
        var frame, cancel;
        var frames = {};
        var lastFrameTime = 0;

        if (
          typeof requestAnimationFrame === "function" &&
          typeof cancelAnimationFrame === "function"
        ) {
          frame = function (cb) {
            var id = Math.random();

            frames[id] = requestAnimationFrame(function onFrame(time) {
              if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {
                lastFrameTime = time;
                delete frames[id];

                cb();
              } else {
                frames[id] = requestAnimationFrame(onFrame);
              }
            });

            return id;
          };
          cancel = function (id) {
            if (frames[id]) {
              cancelAnimationFrame(frames[id]);
            }
          };
        } else {
          frame = function (cb) {
            return setTimeout(cb, TIME);
          };
          cancel = function (timer) {
            return clearTimeout(timer);
          };
        }

        return { frame: frame, cancel: cancel };
      })();

      var getWorker = (function () {
        var worker;
        var prom;
        var resolves = {};

        function decorate(worker) {
          function execute(options, callback) {
            worker.postMessage({ options: options || {}, callback: callback });
          }
          worker.init = function initWorker(canvas) {
            var offscreen = canvas.transferControlToOffscreen();
            worker.postMessage({ canvas: offscreen }, [offscreen]);
          };

          worker.fire = function fireWorker(options, size, done) {
            if (prom) {
              execute(options, null);
              return prom;
            }

            var id = Math.random().toString(36).slice(2);

            prom = promise(function (resolve) {
              function workerDone(msg) {
                if (msg.data.callback !== id) {
                  return;
                }

                delete resolves[id];
                worker.removeEventListener("message", workerDone);

                prom = null;
                done();
                resolve();
              }

              worker.addEventListener("message", workerDone);
              execute(options, id);

              resolves[id] = workerDone.bind(null, { data: { callback: id } });
            });

            return prom;
          };

          worker.reset = function resetWorker() {
            worker.postMessage({ reset: true });

            for (var id in resolves) {
              resolves[id]();
              delete resolves[id];
            }
          };
        }

        return function () {
          if (worker) {
            return worker;
          }

          if (!isWorker && canUseWorker) {
            var code = [
              "var CONFETTI, SIZE = {}, module = {};",
              "(" + main.toString() + ")(this, module, true, SIZE);",
              "onmessage = function(msg) {",
              "  if (msg.data.options) {",
              "    CONFETTI(msg.data.options).then(function () {",
              "      if (msg.data.callback) {",
              "        postMessage({ callback: msg.data.callback });",
              "      }",
              "    });",
              "  } else if (msg.data.reset) {",
              "    CONFETTI.reset();",
              "  } else if (msg.data.resize) {",
              "    SIZE.width = msg.data.resize.width;",
              "    SIZE.height = msg.data.resize.height;",
              "  } else if (msg.data.canvas) {",
              "    SIZE.width = msg.data.canvas.width;",
              "    SIZE.height = msg.data.canvas.height;",
              "    CONFETTI = module.exports.create(msg.data.canvas);",
              "  }",
              "}",
            ].join("\n");
            try {
              worker = new Worker(URL.createObjectURL(new Blob([code])));
            } catch (e) {
              // eslint-disable-next-line no-console
              typeof console !== undefined && typeof console.warn === "function"
                ? console.warn("ðŸŽŠ Could not load worker", e)
                : null;

              return null;
            }

            decorate(worker);
          }

          return worker;
        };
      })();

      var defaults = {
        particleCount: 50,
        angle: 90,
        spread: 45,
        startVelocity: 45,
        decay: 0.9,
        gravity: 1,
        drift: 0,
        ticks: 200,
        x: 0.5,
        y: 0.5,
        shapes: ["square", "circle"],
        zIndex: 100,
        colors: [
          "#26ccff",
          "#a25afd",
          "#ff5e7e",
          "#88ff5a",
          "#fcff42",
          "#ffa62d",
          "#ff36ff",
        ],
        // probably should be true, but back-compat
        disableForReducedMotion: false,
        scalar: 1,
      };

      function convert(val, transform) {
        return transform ? transform(val) : val;
      }

      function isOk(val) {
        return !(val === null || val === undefined);
      }

      function prop(options, name, transform) {
        return convert(
          options && isOk(options[name]) ? options[name] : defaults[name],
          transform
        );
      }

      function onlyPositiveInt(number) {
        return number < 0 ? 0 : Math.floor(number);
      }

      function randomInt(min, max) {
        // [min, max)
        return Math.floor(Math.random() * (max - min)) + min;
      }

      function toDecimal(str) {
        return parseInt(str, 16);
      }

      function colorsToRgb(colors) {
        return colors.map(hexToRgb);
      }

      function hexToRgb(str) {
        var val = String(str).replace(/[^0-9a-f]/gi, "");

        if (val.length < 6) {
          val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];
        }

        return {
          r: toDecimal(val.substring(0, 2)),
          g: toDecimal(val.substring(2, 4)),
          b: toDecimal(val.substring(4, 6)),
        };
      }

      function getOrigin(options) {
        var origin = prop(options, "origin", Object);
        origin.x = prop(origin, "x", Number);
        origin.y = prop(origin, "y", Number);

        return origin;
      }

      function setCanvasWindowSize(canvas) {
        canvas.width = document.documentElement.clientWidth;
        canvas.height = document.documentElement.clientHeight;
      }

      function setCanvasRectSize(canvas) {
        var rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      }

      function getCanvas(zIndex) {
        var canvas = document.createElement("canvas");

        canvas.style.position = "fixed";
        canvas.style.top = "0px";
        canvas.style.left = "0px";
        canvas.style.pointerEvents = "none";
        canvas.style.zIndex = zIndex;

        return canvas;
      }

      function ellipse(
        context,
        x,
        y,
        radiusX,
        radiusY,
        rotation,
        startAngle,
        endAngle,
        antiClockwise
      ) {
        context.save();
        context.translate(x, y);
        context.rotate(rotation);
        context.scale(radiusX, radiusY);
        context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
        context.restore();
      }

      function randomPhysics(opts) {
        var radAngle = opts.angle * (Math.PI / 180);
        var radSpread = opts.spread * (Math.PI / 180);

        return {
          x: opts.x,
          y: opts.y,
          wobble: Math.random() * 10,
          wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),
          velocity:
            opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,
          angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),
          tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,
          color: opts.color,
          shape: opts.shape,
          tick: 0,
          totalTicks: opts.ticks,
          decay: opts.decay,
          drift: opts.drift,
          random: Math.random() + 2,
          tiltSin: 0,
          tiltCos: 0,
          wobbleX: 0,
          wobbleY: 0,
          gravity: opts.gravity * 3,
          ovalScalar: 0.6,
          scalar: opts.scalar,
        };
      }

      function updateFetti(context, fetti) {
        fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;
        fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;
        fetti.wobble += fetti.wobbleSpeed;
        fetti.velocity *= fetti.decay;
        fetti.tiltAngle += 0.1;
        fetti.tiltSin = Math.sin(fetti.tiltAngle);
        fetti.tiltCos = Math.cos(fetti.tiltAngle);
        fetti.random = Math.random() + 2;
        fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);
        fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);

        var progress = fetti.tick++ / fetti.totalTicks;

        var x1 = fetti.x + fetti.random * fetti.tiltCos;
        var y1 = fetti.y + fetti.random * fetti.tiltSin;
        var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;
        var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;

        context.fillStyle =
          "rgba(" +
          fetti.color.r +
          ", " +
          fetti.color.g +
          ", " +
          fetti.color.b +
          ", " +
          (1 - progress) +
          ")";
        context.beginPath();

        if (fetti.shape === "circle") {
          context.ellipse
            ? context.ellipse(
                fetti.x,
                fetti.y,
                Math.abs(x2 - x1) * fetti.ovalScalar,
                Math.abs(y2 - y1) * fetti.ovalScalar,
                (Math.PI / 10) * fetti.wobble,
                0,
                2 * Math.PI
              )
            : ellipse(
                context,
                fetti.x,
                fetti.y,
                Math.abs(x2 - x1) * fetti.ovalScalar,
                Math.abs(y2 - y1) * fetti.ovalScalar,
                (Math.PI / 10) * fetti.wobble,
                0,
                2 * Math.PI
              );
        } else {
          context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));
          context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));
          context.lineTo(Math.floor(x2), Math.floor(y2));
          context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));
        }

        context.closePath();
        context.fill();

        return fetti.tick < fetti.totalTicks;
      }

      function animate(canvas, fettis, resizer, size, done) {
        var animatingFettis = fettis.slice();
        var context = canvas.getContext("2d");
        var animationFrame;
        var destroy;

        var prom = promise(function (resolve) {
          function onDone() {
            animationFrame = destroy = null;

            context.clearRect(0, 0, size.width, size.height);

            done();
            resolve();
          }

          function update() {
            if (
              isWorker &&
              !(
                size.width === workerSize.width &&
                size.height === workerSize.height
              )
            ) {
              size.width = canvas.width = workerSize.width;
              size.height = canvas.height = workerSize.height;
            }

            if (!size.width && !size.height) {
              resizer(canvas);
              size.width = canvas.width;
              size.height = canvas.height;
            }

            context.clearRect(0, 0, size.width, size.height);

            animatingFettis = animatingFettis.filter(function (fetti) {
              return updateFetti(context, fetti);
            });

            if (animatingFettis.length) {
              animationFrame = raf.frame(update);
            } else {
              onDone();
            }
          }

          animationFrame = raf.frame(update);
          destroy = onDone;
        });

        return {
          addFettis: function (fettis) {
            animatingFettis = animatingFettis.concat(fettis);

            return prom;
          },
          canvas: canvas,
          promise: prom,
          reset: function () {
            if (animationFrame) {
              raf.cancel(animationFrame);
            }

            if (destroy) {
              destroy();
            }
          },
        };
      }

      function confettiCannon(canvas, globalOpts) {
        var isLibCanvas = !canvas;
        var allowResize = !!prop(globalOpts || {}, "resize");
        var globalDisableForReducedMotion = prop(
          globalOpts,
          "disableForReducedMotion",
          Boolean
        );
        var shouldUseWorker =
          canUseWorker && !!prop(globalOpts || {}, "useWorker");
        var worker = shouldUseWorker ? getWorker() : null;
        var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;
        var initialized =
          canvas && worker ? !!canvas.__confetti_initialized : false;
        var preferLessMotion =
          typeof matchMedia === "function" &&
          matchMedia("(prefers-reduced-motion)").matches;
        var animationObj;

        function fireLocal(options, size, done) {
          var particleCount = prop(options, "particleCount", onlyPositiveInt);
          var angle = prop(options, "angle", Number);
          var spread = prop(options, "spread", Number);
          var startVelocity = prop(options, "startVelocity", Number);
          var decay = prop(options, "decay", Number);
          var gravity = prop(options, "gravity", Number);
          var drift = prop(options, "drift", Number);
          var colors = prop(options, "colors", colorsToRgb);
          var ticks = prop(options, "ticks", Number);
          var shapes = prop(options, "shapes");
          var scalar = prop(options, "scalar");
          var origin = getOrigin(options);

          var temp = particleCount;
          var fettis = [];

          var startX = canvas.width * origin.x;
          var startY = canvas.height * origin.y;

          while (temp--) {
            fettis.push(
              randomPhysics({
                x: startX,
                y: startY,
                angle: angle,
                spread: spread,
                startVelocity: startVelocity,
                color: colors[temp % colors.length],
                shape: shapes[randomInt(0, shapes.length)],
                ticks: ticks,
                decay: decay,
                gravity: gravity,
                drift: drift,
                scalar: scalar,
              })
            );
          }

          // if we have a previous canvas already animating,
          // add to it
          if (animationObj) {
            return animationObj.addFettis(fettis);
          }

          animationObj = animate(canvas, fettis, resizer, size, done);

          return animationObj.promise;
        }

        function fire(options) {
          var disableForReducedMotion =
            globalDisableForReducedMotion ||
            prop(options, "disableForReducedMotion", Boolean);
          var zIndex = prop(options, "zIndex", Number);

          if (disableForReducedMotion && preferLessMotion) {
            return promise(function (resolve) {
              resolve();
            });
          }

          if (isLibCanvas && animationObj) {
            // use existing canvas from in-progress animation
            canvas = animationObj.canvas;
          } else if (isLibCanvas && !canvas) {
            // create and initialize a new canvas
            canvas = getCanvas(zIndex);
            document.body.appendChild(canvas);
          }

          if (allowResize && !initialized) {
            // initialize the size of a user-supplied canvas
            resizer(canvas);
          }

          var size = {
            width: canvas.width,
            height: canvas.height,
          };

          if (worker && !initialized) {
            worker.init(canvas);
          }

          initialized = true;

          if (worker) {
            canvas.__confetti_initialized = true;
          }

          function onResize() {
            if (worker) {
              // TODO this really shouldn't be immediate, because it is expensive
              var obj = {
                getBoundingClientRect: function () {
                  if (!isLibCanvas) {
                    return canvas.getBoundingClientRect();
                  }
                },
              };

              resizer(obj);

              worker.postMessage({
                resize: {
                  width: obj.width,
                  height: obj.height,
                },
              });
              return;
            }

            // don't actually query the size here, since this
            // can execute frequently and rapidly
            size.width = size.height = null;
          }

          function done() {
            animationObj = null;

            if (allowResize) {
              global.removeEventListener("resize", onResize);
            }

            if (isLibCanvas && canvas) {
              document.body.removeChild(canvas);
              canvas = null;
              initialized = false;
            }
          }

          if (allowResize) {
            global.addEventListener("resize", onResize, false);
          }

          if (worker) {
            return worker.fire(options, size, done);
          }

          return fireLocal(options, size, done);
        }

        fire.reset = function () {
          if (worker) {
            worker.reset();
          }

          if (animationObj) {
            animationObj.reset();
          }
        };

        return fire;
      }

      // Make default export lazy to defer worker creation until called.
      var defaultFire;
      function getDefaultFire() {
        if (!defaultFire) {
          defaultFire = confettiCannon(null, { useWorker: true, resize: true });
        }
        return defaultFire;
      }

      module.exports = function () {
        return getDefaultFire().apply(this, arguments);
      };
      module.exports.reset = function () {
        getDefaultFire().reset();
      };
      module.exports.create = confettiCannon;
    })(
      (function () {
        if (typeof window !== "undefined") {
          return window;
        }

        if (typeof self !== "undefined") {
          return self;
        }

        return this || {};
      })(),
      module,
      false
    );
  </script>
  <script>
    window.confetti = module.exports;
    document.addEventListener("DOMContentLoaded", function () {
      document.getElementById("btn").addEventListener("click", function () {
        flames();
      });
    });
    const flames = () => {
      // alert(1)
      console.log("data");
      var male = document.getElementById("male").value;
      var female = document.getElementById("female").value;
      console.log(male);
      console.log(female);
      var splitmale = male.split("");
      var orgmale = [...splitmale];
      var splitfemale = female.split("");
      var orgfemale = [...splitfemale];

      function getKeyByValue(object, value) {
        var data = "";
        console.log("test", object);
        object.forEach((val, key) => {
          if (val == value) {
            data = key + 1;
          }
        });
        return data;
      }

      orgmale.forEach((da, keys) => {
        var keyss = getKeyByValue(splitfemale, da);

        //console.log("beforesplitfemale", splitfemale);
        if (keyss > 0) {
          // console.log(da, keyss);
          splitfemale = splitfemale.filter((data1, filkey) => {
            //console.log("fillkey", filkey);
            return filkey != keyss - 1;
          });
        }
        // console.log("splitfemale", splitfemale);
      });
      orgfemale.forEach((da, keys) => {
        var keyss = getKeyByValue(splitmale, da);
        console.log(da, keyss);
        if (keyss >= 0) {
          splitmale = splitmale.filter((data1, filkey) => {
            return filkey != keyss - 1;
          });
          console.log(splitmale, "male");
        }
      });
      // console.log(splitmale);
      // console.log(splitfemale);
      var whole = [...splitmale, ...splitfemale];

      // console.log(whole);
      let count = whole.length;
      // console.log("count", count);
      let fla = {
        F: "Friends",
        L: "Love",
        A: "Affection",
        M: "Marriage",
        E: "Enemy",
        S: "Sister",
      };
      var flame = Object.keys(fla);
      var filt = [];
      var lastremove;
      var fcount;
      for (var i = 6; i > 1; i--) {
        // console.log(i);
        var d = count % i;
        console.log("mod", d);
        if (count < 6) {
          if (i != 6) {
            flame = reassign(flame, lastremove);
            console.log(flame.length, "sd");
          }
          fcount = flame.length;
          console.log("fcount=" + fcount);
          if (count > fcount) {
            lastremove = (count % fcount) - 1;
          } else {
            lastremove = count - 1;
          }
          // console.log("before", flame);
          //  console.log("lastremove1", lastremove);

          //  console.log("lastremove", lastremove);
          flame = flame.filter((data, j) => {
            var key = Number(j);
            return key != Number(lastremove);
          });
          //console.log("after", flame);
        } else {
          if (d == 0) {
            if (i != 6) {
              flame = reassign(flame, lastremove);
              //  console.log(flame.length, "sd");
            }
            // console.log("before", flame);
            /// console.log("lastremove1", lastremove);
            lastremove = flame.length - 1;
            // console.log("lastremove", lastremove);
            flame = flame.filter((data, j) => {
              var key = Number(j);
              return key != Number(flame.length - 1);
            });
            console.log("after", flame);
          } else {
            //  console.log("d", d);
            if (i != 6) {
              flame = reassign(flame, lastremove);

              //  console.log(d - 1, "sdbv");
            }
            lastremove = d - 1;
            //  console.log("before", flame);
            flame = flame.filter((data, j) => {
              return j != Number(d - 1);
            });
            //  console.log("after", flame);
          }
        }
      }

      colorbomb();
      setTimeout(() => {
        alert("congratulations:" + fla[flame[0]]);
      }, 1500);
    };

    const reassign = (dataarray, key) => {
      var arraycount = dataarray.length;
      var newarray = [];
      for (var i = key; i < arraycount; i++) {
        newarray.push(dataarray[i]);
      }
      for (var i = 0; i < key; i++) {
        newarray.push(dataarray[i]);
      }
      return newarray;
    };
    const colorbomb = () => {
      var count = 1000;
      var defaults = {
        origin: { y: 0.9 },
      };

      function fire(particleRatio, opts) {
        confetti(
          Object.assign({}, defaults, opts, {
            particleCount: Math.floor(count * particleRatio),
          })
        );
      }

      fire(0.25, {
        spread: 176,
        startVelocity: 55,
      });
      fire(0.2, {
        spread: 60,
      });
      fire(0.35, {
        spread: 100,
        decay: 0.91,
        scalar: 0.8,
      });
      fire(0.1, {
        spread: 120,
        startVelocity: 25,
        decay: 0.92,
        scalar: 1.2,
      });
      fire(0.1, {
        spread: 120,
        startVelocity: 45,
      });
    };
  </script>
</html>
